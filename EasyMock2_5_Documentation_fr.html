<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />	
<title>EasyMock 2.5 Readme</title>
<link rel="stylesheet" href="easymock.css" />
</head>
<body><div class="bodywidth">

<h2>EasyMock 2.5 Readme</h2>
 
<p>Documentation de la version 2.5 (2009-05-24)<br />
&copy; 2001-2009 <a href="http://www.offis.de">OFFIS</a>, <a href="http://tammofreese.de">Tammo Freese</a>, <a href="http://henritremblay.blogspot.fr/">Henri Tremblay</a>.
</p>
<p>Traduit originellement de l'anglais par <a href="http://alexdp.free.fr">Alexandre de Pellegrin</a>.
Maintenue par Henri Tremblay.
</p>
<p>
EasyMock 2 est une librairie fournissant un moyen simple d'utiliser des Mock Objects pour
une interface donnée. EasyMock 2 est disponible sous <a href="License.html">licence MIT</a>.
</p>
<p>
Les Mock Objects simulent le comportement du code
métier et sont capables de vérifier s'il est utilisé
comme prévu.
Les classes métier peuvent être testées
de façon isolée en simulant leurs objets
liés par des Mock Objects.
</p>
<p>
Écrire et maintenir des Mock Objects est souvent une
tâche pénible et source d'erreurs. EasyMock 2
génère les
Mock Objects dynamiquement - pas besoin de les écrire, pas
de code généré!
</p>
<h3>
Avantages d'EasyMock 2
</h3>
<ul>
<li>Pas d'écriture manuelle des Mock Objects.
</li>
<li>Supporte le refactoring sur les Mock Objects : le code de test ne sera pas cassé au runtime lors du renommage de
    méthodes ou de la réorganisations de paramètres
</li>
<li>Supporte les valeurs de retour et les exceptions.
</li>
<li>Supporte la vérification de l'ordre d'appel des méthodes, sur un ou plusieurs Mock Objects.
</li>
</ul>
<h3>Inconvénients d'EasyMock 2
</h3>
<ul>
<li>EasyMock 2 fonctionne uniquement avec Java 2 Version 5.0 ou version supérieure.
</li>
</ul>
<p>
Par défaut, EasyMock supporte la génération de
Mock Objects uniquement pour les interfaces. Pour ceux souhaitant
générer des Mock Objects pour des classes, 
il existe une extension disponible sur la page d'accueil d'EasyMock.
</p>
<h2>
Installation
</h2>
<ol>
<li>Java 2 (minimum 5.0) est requis.
</li>
<li>Décompressez le fichier zip d'EasyMock (<code>easymock2.5.zip</code>). Il contient le répertoire
<code>easymock2.5</code>. Ajoutez le jar d'EasyMock (<code>easymock.jar</code>) de ce répertoire dans votre 
classpath.
</li>
</ol>
<p>
Pour exécuter les tests d'EasyMock, ajoutez <code>tests.zip</code> et le jar de JUnit 4.5
à votre classpath and lancez <code>'java org.easymock.tests.AllTests'</code>.
</p>
<p>
Le code source d'EasyMock est situé dans <code>src.zip</code>.
</p>
<h2>
Utilisation
</h2>
<p>
La plupart des éléments d'un logiciel ne fonctionnent
pas de manière isolée mais en collaboration avec
d'autres éléments (objets liés) pour effectuer leur
tâche.
Dans beaucoup de cas, nous ne nous soucions pas d'utiliser des objets
liés pour nos tests unitaires du moment
que nous avons confiance en eux. Si
ce n'est pas le cas, les Mock Objects peuvent nous aider à
tester unitairement de façon isolée. Les Mock Objects
remplacent les objets liés de l'élément testé.
</p>
<p>
Les exemples suivants utilisent l'interface <code>Collaborator</code>:
</p>
<pre>
package org.easymock.samples;

public interface Collaborator {
    void documentAdded(String title);
    void documentChanged(String title);
    void documentRemoved(String title);
    byte voteForRemoval(String title);
    byte[] voteForRemovals(String[] title);
}
</pre>
<p>
Les implémentations de cette interface sont des
objets liés (des listeners dans ce cas) à la classe nommée <code>ClassUnderTest</code>:
</p>
<pre>
public class ClassUnderTest {
    // ...    
    public void addListener(Collaborator listener) {
        // ... 
    }
    public void addDocument(String title, byte[] document) { 
        // ... 
    }
    public boolean removeDocument(String title) {
        // ... 
    }
    public boolean removeDocuments(String[] titles) {
        // ... 
    }
}
</pre>
<p>
Le code de la classe et de l'interface est disponible dans
le package
<code>org.easymock.samples</code> dans <code>samples.zip</code>.
</p>
<p>
Les exemples qui suivent supposent que vous êtes familier avec le framework de test JUnit.
Bien que les tests montrés ici utilisent JUnit version 3.8.1, vous pouvez également utiliser JUnit 4 ou TestNG.
</p>
<h3>
Votre premier Mock Object
</h3>
<p>
Nous allons maintenant construire un cas de test et jouer avec pour
comprendre les fonctionnalités du package EasyMock. Le
fichier <code>samples.zip</code> contient une version modifiée de ce test. 
Notre premier test devra vérifier que la suppression d'un document non existant <strong>ne doit pas</strong>
provoquer la notification de l'objet lié. Voici le test dans la définition du Mock Object:
</p>
<pre>
package org.easymock.samples;

import junit.framework.TestCase;

public class ExampleTest extends TestCase {

    private ClassUnderTest classUnderTest;
    private Collaborator mock;

    protected void setUp() {
        classUnderTest = new ClassUnderTest();
        classUnderTest.addListener(mock);
    }

    public void testRemoveNonExistingDocument() {    
        // This call should not lead to any notification
        // of the Mock Object: 
        classUnderTest.removeDocument("Does not exist");
    }
}
</pre>
<p>
Pour beaucoup de tests utilisant EasyMock 2, nous avons
uniquement besoin de l'import statique des méthodes de la classe
<code>org.easymock.EasyMock</code>.
Cette classe est la seule non interne et non dépréciée d'EasyMock 2.
</p>
<pre>
import static org.easymock.EasyMock.*;
import junit.framework.TestCase;

public class ExampleTest extends TestCase {

    private ClassUnderTest classUnderTest;
    private Collaborator mock;
    
}    
</pre>
<p>
Pour obtenir un Mock Object, il faut:
</p>
<ol>
<li>créer un Mock Object pour l'interface à simuler,
</li>
<li>enregistrer le comportement attendu, puis
</li>
<li>basculer le Mock Object à l'état 'replay'.
</li>
</ol>
<p>
Voici le premier exemple:
</p>
<pre>
    protected void setUp() {
        mock = createMock(Collaborator.class); // 1
        classUnderTest = new ClassUnderTest();
        classUnderTest.addListener(mock);
    }

    public void testRemoveNonExistingDocument() {
        // 2 (we do not expect anything)
        replay(mock); // 3
        classUnderTest.removeDocument("Does not exist");
    }
</pre>
<p>
Après activation à l'étape 3, <code>mock</code> 
est un Mock Object de l'interface <code>Collaborator</code>
qui n'attend aucun appel. Cela signifie que si nous changeons notre <code>ClassUnderTest</code> 
pour appeler n'importe quelle méthode de l'interface, le Mock Object lèvera 
une <code>AssertionError</code>:
</p>
<pre>
java.lang.AssertionError: 
  Unexpected method call documentRemoved("Does not exist"):
    at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:29)
    at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44)
    at $Proxy0.documentRemoved(Unknown Source)
    at org.easymock.samples.ClassUnderTest.notifyListenersDocumentRemoved(ClassUnderTest.java:74)
    at org.easymock.samples.ClassUnderTest.removeDocument(ClassUnderTest.java:33)
    at org.easymock.samples.ExampleTest.testRemoveNonExistingDocument(ExampleTest.java:24)
    ...
</pre>

<h3>
   Ajouter un comportement
</h3>
<p>
Écrivons un second test. Si un document est ajouté à
la classe testée, nous nous attendons à un appel à
<code>mock.documentAdded()</code>
sur le Mock Object avec le titre du document en argument:
</p>
<pre>
    public void testAddDocument() {
        mock.documentAdded("New Document"); // 2
        replay(mock); // 3
        classUnderTest.addDocument("New Document", new byte[0]); 
    }
</pre>
<p>
Aussi, dans l'étape d'enregistrement (avant d'appeler <code>replay</code>),
le Mock Object ne se comporte pas comme<em></em> un Mock Object mais enregistre 
les appels de méthode. Après l'appel à <code>replay</code>,
il se comporte comme un Mock Object, vérifiant que les appels 
de méthode attendus ont bien lieu.
</p>
<p>
Si <code>classUnderTest.addDocument("New Document", new byte[0])</code>
appelle la méthode attendue avec un mauvais argument, le
Mock Object lèvera une <code>AssertionError</code>:
</p>
<pre>
java.lang.AssertionError: 
  Unexpected method call documentAdded("Wrong title"):
    documentAdded("New Document"): expected: 1, actual: 0
    at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:29)
    at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44)
    at $Proxy0.documentAdded(Unknown Source)
    at org.easymock.samples.ClassUnderTest.notifyListenersDocumentAdded(ClassUnderTest.java:61)
    at org.easymock.samples.ClassUnderTest.addDocument(ClassUnderTest.java:28)
    at org.easymock.samples.ExampleTest.testAddDocument(ExampleTest.java:30)
    ...
</pre>
<p>
Tous les appels attendus n'ayant pas eu lieu sont montrés, ainsi
que tous les appels faits alors qu'ils étaient non attendus
(aucun dans notre cas). Si l'appel à la méthode est
effectué trop de fois, le Mock Object le signale
également:
</p>
<pre>
java.lang.AssertionError: 
  Unexpected method call documentAdded("New Document"):
    documentAdded("New Document"): expected: 1, actual: 2
    at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:29)
    at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44)
    at $Proxy0.documentAdded(Unknown Source)
    at org.easymock.samples.ClassUnderTest.notifyListenersDocumentAdded(ClassUnderTest.java:62)
    at org.easymock.samples.ClassUnderTest.addDocument(ClassUnderTest.java:29)
    at org.easymock.samples.ExampleTest.testAddDocument(ExampleTest.java:30)
    ...
</pre>
<h3>
Vérifier le comportement
</h3>
<p>
Il y a un type d'erreur dont nous ne nous sommes pas
préoccupés jusqu'à présent: si nous décrivons un
comportement, nous voulons vérifier qu'il est bien respecté. 
Le test qui suit passe si une méthode du Mock Object est appelée. 
Pour vérifier cela, nous devons appeler <code>verify(mock)</code>:
</p>
<pre>
    public void testAddDocument() {
        mock.documentAdded("New Document"); // 2 
        replay(mock); // 3
        classUnderTest.addDocument("New Document", new byte[0]);
        verify(mock);
    }
</pre>
<p>
Si la méthode du Mock Object n'est pas appelée, 
l'exception suivante sera levée :
</p>
<pre>
java.lang.AssertionError: 
  Expectation failure on verify:
    documentAdded("New Document"): expected: 1, actual: 0
    at org.easymock.internal.MocksControl.verify(MocksControl.java:70)
    at org.easymock.EasyMock.verify(EasyMock.java:536)
    at org.easymock.samples.ExampleTest.testAddDocument(ExampleTest.java:31)
    ...
</pre>
<p>
Le message de l'exception liste tous les appels attendus qui n'ont pas eu lieu.
</p>
<h3>
Attendre un nombre explicite d'appels
</h3>
<p>
Jusqu'à maintenant, nos tests ont été faits uniquement
sur un seul appel de méthode. Le test suivant
vérifiera que l'ajout d'un document déjà existant
déclenche l'appel à <code>mock.documentChanged()</code>
avec l'argument approprié. Pour en être certain, nous
vérifions cela trois fois (après tout, c'est un exemple
;-)):
</p>
<pre>
    public void testAddAndChangeDocument() {
        mock.documentAdded("Document");
        mock.documentChanged("Document");
        mock.documentChanged("Document");
        mock.documentChanged("Document");
        replay(mock);
        classUnderTest.addDocument("Document", new byte[0]);
        classUnderTest.addDocument("Document", new byte[0]);
        classUnderTest.addDocument("Document", new byte[0]);
        classUnderTest.addDocument("Document", new byte[0]);
        verify(mock);
    }
</pre>
<p>
Afin d'éviter la répétition de <code>mock.documentChanged("Document")</code>,
EasyMock fournit un raccourci. Nous pouvons spécifier le nombre d'appel avec la méthode
<code>times(int times)</code> sur l'objet retourné par <code>expectLastCall()</code>.
Le code ressemble alors à cela:
</p>
<pre>
    public void testAddAndChangeDocument() {
        mock.documentAdded("Document");
        mock.documentChanged("Document");
        expectLastCall().times(3);
        replay(mock);
        classUnderTest.addDocument("Document", new byte[0]);
        classUnderTest.addDocument("Document", new byte[0]);
        classUnderTest.addDocument("Document", new byte[0]);
        classUnderTest.addDocument("Document", new byte[0]);
        verify(mock);
    }
</pre>
<p>
Si la méthode est appelée un trop grand nombre de fois,
une exception sera levée nous indiquant que la méthode a
été appelée trop de fois.
L'erreur est levée immédiatement après le premier
appel dépassant la limite:
</p>
<pre>
java.lang.AssertionError: 
  Unexpected method call documentChanged("Document"):
    documentChanged("Document"): expected: 3, actual: 4
	at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:29)
	at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44)
	at $Proxy0.documentChanged(Unknown Source)
	at org.easymock.samples.ClassUnderTest.notifyListenersDocumentChanged(ClassUnderTest.java:67)
	at org.easymock.samples.ClassUnderTest.addDocument(ClassUnderTest.java:26)
	at org.easymock.samples.ExampleTest.testAddAndChangeDocument(ExampleTest.java:43)
    ...
</pre>
<p>
S'il y a trop peu d'appels, <code>verify(mock)</code>
lève une <code>AssertionError</code>:
</p>
<pre>
java.lang.AssertionError: 
  Expectation failure on verify:
    documentChanged("Document"): expected: 3, actual: 2
	at org.easymock.internal.MocksControl.verify(MocksControl.java:70)
	at org.easymock.EasyMock.verify(EasyMock.java:536)
	at org.easymock.samples.ExampleTest.testAddAndChangeDocument(ExampleTest.java:43)
    ...
</pre>
<h3>
Spécifier des valeurs de retour
</h3>
<p>
Pour spécifier des valeurs de retour, nous encapsulons l'appel attendu dans
<code>expect(T value)</code> et spécifions la valeur de retour avec la 
méthode <code>andReturn(Object returnValue)</code> sur l'objet retourné par
<code>expect(T value)</code>.
</p>
<p>
Prenons par exemple la vérification du workflow lors de la suppression d'un document. 
Si <code>ClassUnderTest</code> fait un appel pour supprimer un document, 
il doit demander aux objets liés de voter pour cette suppression 
par appel à <code>byte voteForRemoval(String title)</code>.
Une réponse positive approuve la suppression. Si la somme de
toutes les réponses est positive, alors le document est
supprimé et l'appel à <code>documentRemoved(String title)</code> 
est effectué sur les objets liés:
</p>
<pre>
    public void testVoteForRemoval() {
        mock.documentAdded("Document");   // expect document addition
        // expect to be asked to vote for document removal, and vote for it
        expect(mock.voteForRemoval("Document")).andReturn((byte) 42);
        mock.documentRemoved("Document"); // expect document removal
        replay(mock);
        classUnderTest.addDocument("Document", new byte[0]);
        assertTrue(classUnderTest.removeDocument("Document"));
        verify(mock);
    }

    public void testVoteAgainstRemoval() {
        mock.documentAdded("Document");   // expect document addition
        // expect to be asked to vote for document removal, and vote against it
        expect(mock.voteForRemoval("Document")).andReturn((byte) -42);
        replay(mock);
        classUnderTest.addDocument("Document", new byte[0]);
        assertFalse(classUnderTest.removeDocument("Document"));
        verify(mock);
    }
</pre>
<p>
Le type de la valeur de retour est vérifié à la
compilation. Par exemple, le code suivant ne compilera pas du fait que
le type fourni ne correspond au type retourné par la
méthode:
</p>
<pre>
    expect(mock.voteForRemoval("Document")).andReturn("wrong type");
</pre>
<p>
Au lieu d'appeler <code>expect(T value)</code> pour
récupérer l'objet auquel affecter une valeur de retour, 
nous pouvons aussi utiliser l'objet retourné par <code>expectLastCall()</code>.
Ainsi, au lieu de 
</p>
<pre>
    expect(mock.voteForRemoval("Document")).andReturn((byte) 42);
</pre>
<p>
nous pouvons écrire
</p>
<pre>
    mock.voteForRemoval("Document");
    expectLastCall().andReturn((byte) 42);
</pre>
<p>
Ce type d'écriture doit uniquement être utilisé
si la ligne est trop longue car il n'inclut pas la vérification
du type à la compilation.
</p>
<h3>
Travailler avec les exceptions
</h3>
<p>
Afin de spécifier les exceptions (plus précisément:
les Throwables) devant être levées, l'objet
retourné par <code>expectLastCall()</code> et <code>expect(T value)</code> 
fournit la méthode <code>andThrow(Throwable throwable)</code>.
Cette méthode doit être appelée durant l'étape
d'enregistrement après l'appel au Mock Object pour lequel le <code>Throwable</code>
doit être levé.
</p>
<p>
Les exception non "checkées" (comme <code>RuntimeException</code>,
<code>Error</code> ainsi que toutes leurs sous classes) peuvent
être levées de n'importe quelle méthode. Les
exceptions "checkées" ne doivent être levées que 
pour méthodes où cela est prévu.
</p>
<h3>
Créer des valeurs de retour ou des exceptions
</h3>
<p>
Parfois, nous voulons que notre Mock Object retourne une valeur ou
lève une exception créée au moment de l'appel.
Depuis la version 2.2 d'EasyMock, l'objet retourné 
par <code>expectLastCall()</code> et <code>expect(T value)</code> fournit la méthode
<code>andAnswer(IAnswer answer)</code> permettant de spécifier une implémentation 
de l'interface <code>IAnswer</code> utilisée pour créer 
une valeur de retour ou une exception.
</p>
<p>
Au sein d'<code>IAnswer</code>, les arguments passés lors de l'appel au mock sont 
disponibles via <code>EasyMock.getCurrentArguments()</code>.
Si vous utilisez cela, les refactorings du type réorganisation
de l'ordre des arguments briseront vos tests. Vous êtes prévenu.
</p>
<p>
Une alternative à <code>IAnswer</code> sont les méthodes <code>andDelegateTo</code> et 
<code>andStubsDelegateTo</code>. Elles permettent de déléguer un appel à une
implémentation concrète de l'interface "mockées" et qui fournira la valeur de retour. 
L'avantage est que les paramètres normalement récupéré avec <code>EasyMock.getCurrentArguments()</code> 
pour <code>IAnswer</code> sont maintenant passés à la méthode de l'implémentation concrète. 
Ça supporte donc le refactoring. Le désavantage est qu'il faut fournir une implémentation... 
ce qui resemble un peu à faire un mock à la main. Ce que vous tentez d'éviter en utilisant 
EasyMock. Il peut aussi être pénible d'implémenter l'interface si celle-ci à beaucoup de méthodes. Finalement, 
le type de l'implémentation ne peut être vérifié statiquement par rapport au type du Mock Object. 
Si pour une quelconque raison, la class concrète n'implémente plus la méthode sur laquelle est 
délégué l'appel, vous aurez une exception lors de la phase de "replay". Ce cas devrait toutefois
être assez rare.  
</p>
<p>
Pour bien comprendre les deux options, voici un exemple:
</p>
<pre>
    List&lt;String&gt; l = createMock(List.class);

    // andAnswer style
    expect(l.remove(10)).andAnswer(new IAnswer&lt;String&gt;() {
        public String answer() throws Throwable {
            return getCurrentArguments()[0].toString();
        }
    });

    // andDelegateTo style
    expect(l.remove(10)).andDelegateTo(new ArrayList&lt;String&gt;() {
        @Override
        public String remove(int index) {
            return Integer.toString(index);
        }
    });
</pre>
<h3>
Changer de comportement sur le même appel de méthode
</h3>
<p>
Il est également possible de spécifier un changement de comportement pour une méthode.
Les méthodes <code>times</code>, <code>andReturn</code> et <code>andThrow</code>
peuvent être chaînées. Comme exemple, 
nous définissons <code>voteForRemoval("Document")</code> pour
</p>
<ul>
<li>retourner 42 pour les trois premiers appels,
</li>
<li>lever une <code>RuntimeException</code> sur le quatrième appel,
</li>
<li>renvoyer -42 une fois.
</li>
</ul>
<pre>
    expect(mock.voteForRemoval("Document"))
        .andReturn((byte) 42).times(3)
        .andThrow(new RuntimeException(), 4)
        .andReturn((byte) -42);
</pre>
<h3>
Être plus permissif sur le nombre d'appels
</h3>
<p>
Afin d'être plus permissif sur le nombre d'appels attendus,
des méthodes additionnelles peuvent être
utilisées à la place de <code>times(int count)</code>:
</p>
<dl>
<dt><code>times(int min, int max)</code></dt> 
<dd>pour attendre entre <code>min</code> and <code>max</code> appels,</dd>
<dt><code>atLeastOnce()</code></dt>
<dd>pour attendre au moins un appel, et</dd>
<dt><code>anyTimes()</code></dt>
<dd>pour attendre une quantité non définie d'appels.</dd>
</dl>
<p>
Si aucun nombre d'appels n'est explicitement défini,
alors seul un appel est attendu. Pour le définir explicitement,
vous pouvez utiliser <code>once()</code> ou <code>times(1)</code>.
</p>
<h3>
Mocks stricts
</h3>
<p>
Sur un Mock Object retourné par <code>EasyMock.createMock()</code>,
l'ordre d'appel des méthodes n'est pas vérifié.
Si vous souhaitez avoir un Mock Object 'strict' vérifiant cet ordre,
utilisez <code>EasyMock.create<i>Strict</i>Mock()</code>.</p>
<p>
Lorsqu'un appel inattendu à une méthode est fait sur
un Mock Object 'strict', le message de l'exception contient les appels 
de méthode attendus à ce moment, suivi du premier appel en
conflit. <code>verify(mock)</code> montre tous les appels de méthode manqués.
</p>
<h3>
Activer/Désactiver la vérification de l'ordre d'appel des méthodes
</h3>
<p>
Il est parfois nécessaire qu'un Mock Object vérifie
l'ordre d'appel sur certains appels uniquement. Pendant la phase
d'enregistrement, vous pouvez activer la vérification de l'ordre
d'appel en utilisant <code>checkOrder(mock, true)</code> et la 
désactiver en utilisant <code>checkOrder(mock, false)</code>.
</p>
<p>
Il y a deux différences entre un Mock Object 'strict' et un Mock Object 'normal':
</p>
<ol>
	<li> Un mock 'strict' a la vérification de l'ordre d'appel activé à la création. </li>
	<li> Un mock 'strict' a la vérification de l'ordre d'appel activé après un reset (voir <em>Réutilisation d'un Mock Object</em>). </li>
</ol>
<h3>
Définir des comparateurs d'arguments pour plus de souplesse
</h3>
<p>
Pour vérifier la correspondance à un appel de méthode prévu sur un Mock Object, 
les arguments<code> de type Object</code> sont comparés, par défaut, avec
<code>equals()</code>. Cela peut introduire des problèmes. Considérons l'exemple suivant:
</p>
<pre>
String[] documents = new String[] { "Document 1", "Document 2" };
expect(mock.voteForRemovals(documents)).andReturn(42);
</pre>
<p>
Si la méthode est appelée avec un autre tableau ayant le même contenu,
cela provoque une exception du fait que <code>equals()</code> compare l'identité 
des objets pour les tableaux:
</p>
<pre>
java.lang.AssertionError: 
  Unexpected method call voteForRemovals([Ljava.lang.String;@9a029e):
    voteForRemovals([Ljava.lang.String;@2db19d): expected: 1, actual: 0
    documentRemoved("Document 1"): expected: 1, actual: 0
    documentRemoved("Document 2"): expected: 1, actual: 0
	at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:29)
	at org.easymock.internal.ObjectMethodsFilter.invoke(ObjectMethodsFilter.java:44)
	at $Proxy0.voteForRemovals(Unknown Source)
	at org.easymock.samples.ClassUnderTest.listenersAllowRemovals(ClassUnderTest.java:88)
	at org.easymock.samples.ClassUnderTest.removeDocuments(ClassUnderTest.java:48)
	at org.easymock.samples.ExampleTest.testVoteForRemovals(ExampleTest.java:83)
    ...
</pre>
<p>
Pour spécifier que seule l'égalité de tableau
est nécessaire pour cet appel, utilisez la méthode 
<code>aryEq</code>, importée statiquement de la classe <code>EasyMock</code>:
</p>
<pre>
String[] documents = new String[] { "Document 1", "Document 2" };
expect(mock.voteForRemovals(aryEq(documents))).andReturn(42);
</pre>
<p>
Si vous souhaitez utiliser les comparateurs lors d'un appel, vous devez
en utiliser pour chaque argument de la méthode appelée.
</p>
<p>
Voici quelques comparateurs prédéfinis disponible:
</p>
<dl>

<dt><code>eq(X value)</code></dt>
<dd>Vérifie que la valeur reçue égale la valeur attendue. Disponible pour tous les types primitifs et objets.</dd>

<dt><code>anyBoolean()</code>, <code>anyByte()</code>, <code>anyChar()</code>, <code>anyDouble()</code>, <code>anyFloat()</code>, <code>anyInt()</code>, <code>anyLong()</code>, <code>anyObject()</code>, <code>anyShort()</code></dt>
<dd>Laisse passer n'importe quelle valeur. Disponible pour tous les types primitifs et objets.</dd>

<dt><code>eq(X value, X delta)</code></dt>
<dd>Vérifie que la valeur reçue égale la valeur attendue, plus ou moins un delta. Disponible pour les <code>float</code> et <code>double</code>.</dd>

<dt><code>aryEq(X value)</code></dt>
<dd>Vérifie que la valeur reçue égale la valeur attendue en s'appuyant sur <code>Arrays.equals()</code>. Disponible pour les tableaux d'objets et de types primitifs.</dd>

<dt><code>isNull()</code></dt>
<dd>Vérifie que la valeur reçue est nulle. Disponible pour les objets.</dd>

<dt><code>notNull()</code></dt>
<dd>Vérifie que la valeur reçue n'est pas nulle. Disponible pour les objets.</dd>

<dt><code>same(X value)</code></dt>
<dd>Vérifie que la valeur reçue est la même que la value attendue. Disponible pour les objets.</dd>

<dt><code>isA(Class clazz)</code></dt>
<dd>Vérifie que la valeur reçue est une instance de clazz ou d'une classe hérite ou implémente clazz. Disponible pour les objets.</dd>

<dt><code>lt(X value)</code>, <code>leq(X value)</code>, <code>geq(X value)</code>, <code>gt(X value)</code></dt>
<dd>Vérifie que la valeur reçue est inférieure/inférieure ou égale/supérieure
ou égale/supérieure à la valeur attendue. Disponible pour tous les types primitifs numériques et les implémentations de <code>Comparable</code>.</dd>

<dt><code>startsWith(String prefix), contains(String substring), endsWith(String suffix)</code></dt>
<dd>Vérifie que la valeur reçue commence par/contient/se termine par la valeur attendue. Disponible pour les <code>String</code>s.</dd>

<dt><code>matches(String regex), find(String regex)</code></dt>
<dd>Vérifie que la valeur reçue/une sous-chaîne de la valeur reçue correspond à l'expression ré. Disponible pour les <code>String</code>s.</dd>

<dt><code>and(X first, X second)</code></dt>
<dd>Est valide si les résultats des deux comparateurs utilisés en <code>first</code> et <code>second</code> sont vérifiés. Disponible pour tous les types primitifs et objets.</dd>

<dt><code>or(X first, X second)</code></dt>
<dd>Est valide si l'un des résultats des deux comparateurs utilisés en <code>first</code> et <code>second</code> est vérifié. Disponible pour tous les types primitifs et objets.</dd>

<dt><code>not(X value)</code></dt>
<dd>Est valide si le résultat du comparateur utilisé dans <code>value</code> est négatif.</dd>

<dt><code>cmpEq(X value)</code></dt>
<dd>Vérifie que la valeur reçue égale la valeur attendue du point de vue de <code>Comparable.compareTo(X o)</code>. Disponible pour tous les types primitifs numériques et les implémentations de <code>Comparable</code>.</dd>

<dt><code>cmp(X value, Comparator&lt;X&gt; comparator, LogicalOperator operator)</code></dt>
<dd>Vérifie que <code>comparator.compare(reçue, value) operator 0</code> où <code>operator</code> est &lt;,&lt;=,&gt;,&gt;= ou ==.</dd>

<dt><code>capture(Capture&lt;T&gt; capture)</code></dt>
<dd>Laisse passer n'importe quelle valeur mais la capture dans le paramètre <code>Capture</code> pour un usage ultérieurs. Vous pouvez utiliser <code>and(someMatcher(...), capture(c))</code> pour 
capturer le paramètre d'un appel de méthode en particulier. Vous pouvez aussi spécifier le <code>CaptureType</code> pour indiquer à l'objet
<code>Capture</code> de conserver le premier (<code>FIRST</code>), le dernier (<code>LAST</code>), tous (<code>ALL</code>) ou aucun (<code>NONE</code>) des objets capturés</dd>

</dl>

<h3>
Définir son propre comparateur d'arguments
</h3>
<p>
Il peut être intéressant de définir son propre
comparateur d'argument. Prenons un comparateur dont le rôle
serait de vérifier une exception par rapport à son
type et message. Il pourrait être utilisé de la façon suivante:
</p>
<pre>
    IllegalStateException e = new IllegalStateException("Operation not allowed.")
    expect(mock.logThrowable(eqException(e))).andReturn(true);
</pre>
<p>
Deux étapes sont nécessaires pour réaliser cela: le nouveau comparateur
doit être défini et la méthode statique <code>eqException</code> 
doit être déclarée.
</p>
<p>
Pour définir le nouveau comparateur d'argument, nous implémentons l'interface <code>org.easymock.IArgumentMatcher</code>.
Cette interface contient deux méthodes: <code>matches(Object actual)</code>, vérifiant 
que l'argument reçu est bien celui attendu, et <code>appendTo(StringBuffer buffer)</code>,
ajoutant au StringBuffer une chaîne de caractères représentative du comparateur d'argument.
L'implémentation est la suivante :
</p>
<pre>
import org.easymock.IArgumentMatcher;

public class ThrowableEquals implements IArgumentMatcher {
    private Throwable expected;

    public ThrowableEquals(Throwable expected) {
        this.expected = expected;
    }

    public boolean matches(Object actual) {
        if (!(actual instanceof Throwable)) {
            return false;
        }
        String actualMessage = ((Throwable) actual).getMessage();
        return expected.getClass().equals(actual.getClass())
                &amp;&amp; expected.getMessage().equals(actualMessage);
    }

    public void appendTo(StringBuffer buffer) {
        buffer.append("eqException(");
        buffer.append(expected.getClass().getName());
        buffer.append(" with message \"");
        buffer.append(expected.getMessage());
        buffer.append("\"")");

    }
}
</pre>
<p>
La méthode <code>eqException</code> doit instancier le
comparateur d'argument avec l'objet Throwable donné, le fournir
à EasyMock via la méthode statique <code>reportMatcher(IArgumentMatcher matcher)</code>
et retourner une valeur afin d'être utilisée au sein de l'appel à la méthode mockée 
(typiquement <code>0</code>, <code>null</code> ou <code>false</code>). Une première tentative ressemblerait à ceci:
</p>
<pre>
public static Throwable eqException(Throwable in) {
    EasyMock.reportMatcher(new ThrowableEquals(in));
    return null;
}
</pre>
<p>
Cependant, cela ne fonctionnerait que si la méthode <code>logThrowable</code>
de l'exemple acceptait <code>Throwable</code>s et quelque chose de plus spécifique du style de <code>RuntimeException</code>. 
Dans ce dernier cas, le code de notre exemple ne compilerait pas:
</p>
<pre>
    IllegalStateException e = new IllegalStateException("Operation not allowed.")
    expect(mock.logThrowable(eqException(e))).andReturn(true);
</pre>
<p>
Java 5.0 à la rescousse: Au lieu de définir <code>eqException</code>
avec un <code>Throwable</code> en paramètre, nous utilisons un type générique 
qui hérite de <code>Throwable</code>:
</p>
<pre>
public static &lt;T extends Throwable&gt; T eqException(T in) {
    reportMatcher(new ThrowableEquals(in));
    return null;
}
</pre>
<h3>
Réutilisation d'un Mock Object
</h3>
<p>
Les Mock Objects peuvent être réinitialisés avec <code>reset(mock)</code>.
</p>
<p>
Au besoin, un Mock Object peut aussi être converti d'un type à l'autre en appelant <code>resetToNice(mock)</code>, 
<code>resetToDefault(mock)</code> ou <code>resetToStrict(mock)</code>.
</p>
<h3>
Utilisation d'un comportement de "stub" pour les méthodes
</h3>
<p>
Dans certains cas, nous voudrions que nos Mock Object répondent
à certains appels, mais sans tenir compte du nombre de fois, de l'ordre
ni même s'ils ont été eu lieu.
Ce comportement de "stub" peut être défini en utilisant
les méthodes <code>andStubReturn(Object value)</code>, 
<code>andStubThrow(Throwable throwable)</code>, <code>andStubAnswer(IAnswer&lt;t&gt; answer)</code>
et <code>asStub()</code>. Le code suivant configure le Mock Object pour répondre 42 
à <code>voteForRemoval("Document")</code> une fois et -1 pour tous les autres arguments:
</p>
<pre>
    expect(mock.voteForRemoval("Document")).andReturn(42);
    expect(mock.voteForRemoval(not(eq("Document")))).andStubReturn(-1);
</pre>
<h3>
Création de mocks dits "gentils"
</h3>
<p>
Pour un Mock Object retourné par <code>createMock()</code>, le comportement par défaut pour toutes 
les méthodes est de lever une <code>AssertionError</code> pour tous les appels non prévus.
Si vous souhaitez avoir un Mock Object "gentil" autorisant, par défaut, l'appel à 
toutes les méthodes et retournant la valeur vide appropriée (<code>0</code>, <code>null</code>
ou <code>false</code>), utilisez <code>create<i>Nice</i>Mock()</code> au lieu de <code>createMock()</code>.
</p>

<a id="Object_Methods"/><h3>Méthodes de la classe Object</h3>
<p>
Les comportements des trois méthodes <code>equals()</code>,
<code>hashCode()</code> et <code>toString()</code>
ne peuvent être changés sur des Mock Objects créés avec EasyMock,
même si elles font partie de l'interface duquel le Mock Object est créé.
</p>
<h3>Vérifier l'ordre d'appel des méthodes entre plusieurs Mocks</h3>
<p>
Jusqu'à présent, nous avons vu un Mock Object comme étant
seul et configuré par les méthodes statiques de la classe <code>EasyMock</code>. 
Mais beaucoup de ces méthodes statiques font référence à l'objet "control"
caché de chaque Mock Object et lui délègue l'appel. Un
Mock Control est un objet implémentant l'interface <code>IMocksControl</code>.
</p>
<p>
Du coup, au lieu de
</p>
<pre>
    IMyInterface mock = createStrictMock(IMyInterface.class);
    replay(mock);
    verify(mock); 
    reset(mock);
</pre>
<p>
nous pourrions utiliser le code équivalent:
</p>
<pre>
    IMocksControl ctrl = createStrictControl();
    IMyInterface mock = ctrl.createMock(IMyInterface.class);
    ctrl.replay();
    ctrl.verify(); 
    ctrl.reset();
</pre>
<p>
L'interface <code>IMocksControl</code> permet de créer plus d'un seul Mock Object. 
Ainsi, il est possible de vérifier l'ordre d'appel des méthodes entre les mocks. 
Par exemple, configurons deux mock objects pour l'interface <code>IMyInterface</code> pour lesquels 
nous attendons respectivement les appels à <code>mock1.a()</code> et <code>mock2.a()</code>, 
un nombre indéfini d'appels à <code>mock1.c()</code> et <code>mock2.c()</code>, 
et enfin <code>mock2.b()</code> et <code>mock1.b()</code>, dans cet ordre:
</p>
<pre>
    IMocksControl ctrl = createStrictControl();
    IMyInterface mock1 = ctrl.createMock(IMyInterface.class);
    IMyInterface mock2 = ctrl.createMock(IMyInterface.class);

    mock1.a();
    mock2.a();

    ctrl.checkOrder(false);

    mock1.c();
    expectLastCall().anyTimes();     
    mock2.c();
    expectLastCall().anyTimes();     

    ctrl.checkOrder(true);

    mock2.b();
    mock1.b();

    ctrl.replay();
</pre>
<h3>Nommer un Mock Object</h3>
<p>
Les Mock Objects peuvent ê nommés à leur création en utilisant 
<code>createMock(String name, Class&lt;T&gt; toMock)</code>,
<code>createStrictMock(String name, Class&lt;T&gt; toMock)</code> ou
<code>createNiceMock(String name, Class&lt;T&gt; toMock)</code>.
Les noms seront affichés dans le message des <code>AssertionError</code>.
</p>
<h3>Sérializer un Mock Object</h3>
<p>
Un Mock Object peut être sérializé à n'importe quelle étape de son 
existence. Il y a toutefois des contraintes évidentes:
</p>
<ul>
<li>Les comparateurs d'arguments utilisés doivent être sérializable (ceux fournis avec EasyMock le sont)
</li>
<li>Les paramètres enregistrés doivent être sérializable
</li>
</ul>
<h3>Traitement multifil</h3>
<p>
Pendant la phase d'enregistrement un Mock Object <b>n'est pas</b> à fil sécurisé. Un Mock Object donné (ou des Mock Objects liés au
même <code>MockControl</code>) ne peut être enregistré que d'un seul fil. Toutefois, plusieurs Mock Objects peuvent être enregistrés
simultanément dans des fils différents.
</p>
<p>
Durant la phase de rejeu, un Mock Object sera à fil sécurisé par défaut. Ceci peut être changé en appelant <code>makeThreadSafe(mock, false)</code>.
durant la phase d'enregistrement. Cela peut permettre d'éviter des interblocages dans certaines rares situations.
</p>
<p>
Finallement, appeler <code>checkIsUsedInOneThread(mock, true)</code> permet de s'assurer qu'un Mock Object ne sera appelé que d'un seul
fil. Une exception sera lancé sinon. Cela peut être pratique dans le cas où l'objet "mocké" n'est pas à fil sécurisé et que l'on veut
s'assurer qu'il est utilisé correctement.
</p>
<h3>Modifier les comportements d'EasyMock</h3>
<p>
EasyMock fournit un mécanisme de gestion de propriétés permettant de modifier son comportement. Il vise
principalement à permettre le retour à un comportement antérieur à la version courante. Les propriétés
actuellement supportées sont:
</p>
<dl>
<dt><code>easymock.notThreadSafeByDefault</code></dt>
<dd>Si true, les Mock Objects ne seront pas à fil sécurisé par défaut. Values possibles: "true" ou "false". Défaut: false</dd>
<dt><code>easymock.enableThreadSafetyCheckByDefault</code></dt>
<dd>Si true, un mock ne pourra être appelé que d'un seul fil. Values possibles: "true" ou "false". Défaut: false</dd>
</dl>
<p>
Les propriétés peuvent être mise de trois façons. Chaque étape de la liste peut écraser une précédente.
</p>
<ul>
<li>Dans le fichier <code>easymock.properties</code> mis dans le package défaut du classpath 
</li>
<li>Comme propriété système 
</li>
<li>En appelant <code>EasyMock.setEasyMockProperty</code>. Des constantes sont disponibles 
dans la classe <code>EasyMock</code>
</li>
</ul>
<h3>
Compatibilité avec les anciennes versions
</h3>
<p>
EasyMock 2 contient une couche de compatibilité. Ainsi, les
tests utilisant EasyMock 1.2 en Java 1.5 fonctionneront sans aucune modification. 
Les seules différences connues sont visibles lorsque qu'un test est en erreur: il y a de
légers changements dans les messages d'erreur, les stack traces et les erreurs 
sont maintenant remontées en utilisant <code>AssertionError</code> de Java 
au lieu de <code>AssertionFailedError</code> de JUnit.
</p>
<p>EasyMock 2.1 introduisait une fonctionnalité de callback
qui a été retirée dans EasyMock 2.2, car trop complexe. 
Depuis EasyMock 2.2, l'interface <code>IAnswer</code>
fournit la fonctionnalité de callback. 
</p>
<h3>OSGi</h3>
<p>
Le jar d'EasyMock peut être utilisé comme bundle OSGi. Il export les packages
<code>org.easymock</code>, <code>org.easymock.internal</code> 
et <code>org.easymock.internal.matchers</code>. Toutefois, pour importer les deux
derniers, vous spécifier l'attribut <code>poweruser</code> à "true" (<code>poweruser=true</code>). 
Ces packages sont prévus d'être utilisés pour étendre EasyMock, ils n'ont donc pas besoins d'être
importés habituellement.
</p>
<h2>
Développement d'EasyMock
</h2>
<p>
EasyMock 1.0 a été développé par Tammo Freese chez OFFIS. La maintenance est effectuée
par Henri Tremblay depuis 2007. Le développement d'EasyMock est hébergé par SourceForge
pour permettre à d'autres développeurs et sociétés d'y contribuer.
</p>
<p>
Remerciements à ceux qui nous ont fourni retour d'expérience et rustines, incluant
Nascif Abousalh-Neto, Dave Astels, Francois Beausoleil, George Dinwiddie, Shane Duan, 
Wolfgang Frech, Steve Freeman, Oren Gross, John D. Heintz, Dale King, Brian Knorr,
Dierk Koenig, Chris Kreussling, Robert Leftwich, Patrick Lightbody, Johannes Link, 
Rex Madden, David McIntosh, Karsten Menne, Bill Michell,
Stephan Mikaty, Ivan Moore, Ilja Preuss, Justin Sampson, Markus Schmidlin, Richard Scott,
Joel Shellman, Jiří Mareš, Alexandre de Pellegrin
Shaun Smith, Marco Struck, Ralf Stuckert, Victor Szathmary, Bill Uetrecht,
Frank Westphal, Chad Woolley, Bernd Worsch, et de nombreux autres.
</p>
<p>
Merci de consulter la <a href="http://www.easymock.org">page d'accueil EasyMock</a> 
pour être informé des nouvelles versions et transmettez vos bogues et suggestions à
<a href="mailto:easymock@yahoogroups.com?subject=EasyMock 2.5 feedback">EasyMock Yahoo!Group</a> (en anglais SVP).
Si vous souhaitez souscrire au EasyMock Yahoo!Group, envoyez un message à
<a href="mailto:easymock-subscribe@yahoogroups.com">easymock-subscribe@yahoogroups.com</a>.
</p>
<h3>
EasyMock Version 2.5 (2009-05-24), Notes de Mise à Jour
</h3>
<p>
Nouveau dans la version 2.5:
</p>
<ul>
<li>Message d'erreur pour les fils sécurisés amélioré (2342332)
</li>
<li>Les Mock Objects sont maintenant à fil sécurisé par défaut (2169027)
</li>
<li>Par défaut, il n'y a plus de vérification de l'utilisation d'un mock dans un seul fil  (2169027)
</li>
<li>Propriétés permettants d'avoir le comportement des versions précédentes
</li>
<li>Les propriétés <code>easymock.notThreadSafeByDefault</code> et <code>easymock.enableThreadSafetyCheckByDefault</code> permettent d'être rétrocompatible (2169027)
</li>
<li>Amélioration du message d'erreur pour les paramètres de type tableau (2550502)
</li>
<li>Tout construire avec Maven
</li>
<li>Ajout de l'en-tête OSGi au MANIFEST.MF (2595775)
</li>
<li>Ajout de andDelegateTo et andStubDelegateTo (2708883)
</li>
<li>Migrer vers Subversion
</li>
<li>Ajout du <code>CaptureType</code> (capturer premier, dernier, tous, aucun) (2446744)
</li>
<li>Donner un comportement plus simple à la capture (2617107, 2133741)
</li>
<li>Une NPE pouvait se produire lors de l'enregistrement d'une méthode à paramètres variables (2078444)
</li>
<li>Message d'erreur plus clair sur les appels effectifs et attendus (2744605)
</li>
<li>Ne pas appeler <code>fillInStackTrace()</code> lorsqu'une exception est lancée par IAnswer ou une réponse déléguée
pour aider le déboguage des tests (2771518)
</li>
</ul>
<p>
Nouveau dans la version 2.4:
</p>
<ul>
<li>Pouvoir capturer un argument passé à un Mock Object (1963449)
</li>
<li>Ajout des méthodes resetToNice/Default/Strict methods (1963442)
</li>
<li>Rendre les Comparators génériques plus flexibles
</li>
<li>Les Mock Objects sont maintenant sérializable (1895630)
</li>
<li>Il est maintenant possible de continuer normalement après une assertion ignorée (1896509)
</li>
<li>Possibilité de rendre un Mock Object à fil sécurisé (1895644,1953275)
</li>
<li>Vérification qu'un Mock Object non sécurisé n'est pas utilisé dans un environnement multifil 
</li>
</ul>
<p>
Nouveau dans la version 2.3:
</p>
<ul>
<li>Documentation en français
</li>
<li>Comparateurs pour arguments de type Comparable
</li>
<li>Correction de la comparaison de nombres décimaux
</li>
<li>Les Mock Objects peuvent maintenant être nommés
</li>
<li>Includ le fix de Bill Michell pour sur les ThreadLocals
</li>
<li>Migration des test unitaires d'EasyMock vers JUnit 4
</li>
</ul>
<p>
Nouveau dans la version 2.2:
</p>
<ul>
<li>la réponse aux appels peut ètre créée au moment de l'appel via
<code>andAnswer(IAnswer answer)</code> et <code>andStubAnswer(IAnswer answer)</code>
</li>
<li><code>callback(Runnable runnable)</code> a été retiré, pour un callback, veuillez 
convertir à
<code>andAnswer(IAnswer answer)</code> et <code>andStubAnswer(IAnswer answer)</code>
</li>
<li><code>replay()</code>, <code>verify()</code> et <code>reset()</code> acceptent maintenant
plusieurs mock objects comme arguments
</li>
</ul>
<p>
Nouveau dans la version 2.1:
</p>
<ul>
<li>les arguments passés à un mock object sont à disponibles dans un callback via 
<code>EasyMock.getCurrentArguments()</code>
</li>
<li>Correction du bogue reporté par http://groups.yahoo.com/group/easymock/message/558
</li>
<li>remontée plus rapide d'une erreur si des comparateurs ne sont pas utilisés
</li>
</ul>
<p>
Nouveau dans la version 2.0:
</p>
<ul>
<li>support de comparateurs d'arguments souple et ré au refactoring-safe
</li>
<li>aucun mock control n'est nécessaire pour un Mock Object solitaire
</li>
<li>le comportement de "stub" remplace le comportement "défaut"
</li>
<li>support de la vérification d'ordre d'appels entre plusieurs mocks 
avec possibilité d'activer/désactiver cette vérification
</li>
<li>support de callbacks
</li>
<li>EasyMock lève désormais des <code>java.lang.AssertionError</code> au lieu 
de <code>junit.framework.AssertionFailedError</code> ce qui permet d'être indépendant 
du framework de test. Vous pouvez l'utiliser avec JUnit 3.8.x, JUnit 4 et TestNG
</li>
<li>ancienne API dépréciée
</li>
</ul>
</div>
</body>
</html>
